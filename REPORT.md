# Report
Bas Zwanenburg
11980370

## Korte beschrijving
De app implementeert een typspelletje, waarbij de speler zo snel mogelijk een stuk tekst dient over te typen. Dit stukje tekst vormt de plot van een recente of aankomende film, en de film waarbij deze beschrijving hoort wordt na alles correct over te typen onthult. Indien de speler is ingelogd, wordt de beste prestatie voor elk stukje tekst opgeslagen in een leaderboard met behulp van Firebase.

![Screenshot](/docs/SingleScreenshot.png)

## Technische design
De app is als volgt opgebouwd. In totaal zijn er negen java files geschreven. Vijf hiervan zijn activities en representeren de vijf verschillende schermen waar de app over beschikt:
- ActivityHome: Het home menu, dit is het eerste scherm dat de gebruiker ziet wanneer de app wordt opgestart. Dit wordt gebruikt om de gebruiker te navigeren naar het login scherm (en indirect het registratie scherm) of naar het spelscherm, waar de kernfunctionaliteiten van de app zich bevinden. Ook kan de gebruiker zich hier uitloggen (indien er iemand al is ingelogd).
- ActivityLogin: Met behulp van een login formulier en Firebase kunnen gebruikers zich hier inloggen. Inloggen is vereist om data op te slaan naar Firebase (in dit geval de high scores van spelers in een leaderboard).
- ActivityRegister: Met behulp van een registratieformulier en Firebase kunnen gebruikers zich hier laten registreren.
- ActivityType: Dit is het spelscherm. Het bevat een TextView waarin een filmbeschrijving via TMDB API wordt ingeladen, en een EditText field waarin de gebruiker de TextView moet overtypen. Dit houdt de scores bij en hier worden ook de scores in Firebase opgeslagen.
- ActivityResult: Het resultatenscherm is de 'laatste' view van de app. Hier worden de details van de bij de voorafgaande TextView horende film weergegeven. Ook worden hier de gebruikers statistieken van het afgelopen potje nogmaals getoond. Tot slot wordt de leaderboard van de desbetreffende film in een listview genummerd.

De activities worden aangevuld met de volgende drie classes:
- ClassUser: Deze class wordt uitsluitend gebruikt voor authenticatie en het inloggen en registreren van users met Firebase.
- ClassMovie: Hiermee worden alle details van de film gegroepeerd. Elke instance van deze class kan met een intent gemakkelijk van de ActivityType naar de ActivityResult worden verstuurd, waar de details met de in de class gedefinieerde functies kunnen worden opgehaald.
- ClassLeaderboard: Deze class wordt gebruikt om de Leaderboard op te vullen, maar ook om het weer te geven in een listview (met behulp van een adapter).

Tot slot wordt er gebruikgemaakt van een adapter (MyAdapter), die voor elke item in de Leaderboard de juiste informatie in een lijst toont. De adapter maakt gebruik van een aparte layout file (XML).

![Opbouw code](/docs/Opbouw_Code.png)

## Uitdagingen en aanpassingen
Tijdens het programmeren ben ik een aantal uitdagingen tegen het lijf gelopen. De belangrijkste hiervan is het implementeren van multiplayer functionaliteit, waarbij spelers in realtime tegen elkaar zouden kunnen spelen. De bedoeling hierbij was om de snelheid en progressie van de andere spelers in andere laadbalkjes weer te geven. Door meerdere laadbalkjes onder elkaar te zetten zou dan duidelijk gevisualiseerd worden wie in het potje het beste presteert. Ik wilde dit met behulp van bluetooth of WiFi lokaal doen, zodat geen externe server hoefde worden opgezet. Eén van de grootste problemen die ik hierbij ondervond, was dat ik er zeker van moest zijn dat elke gebruiker in dezelfde sessie ook daadwerkelijk dezelfde TextView krijgt, terwijl dit via de API random wordt gegenereed. Ook had ik een lobby nodig waarin spelers elkaar kunnen joinen. Vanwege een overvloed aan ingewikkelde API's heb ik in week 3 ervoor besloten om het idee te schrappen. Tijdens de presentatie van week 2 werd al een suggestie gegeven om in plaats hiervan de data van willekeurige spelers uit Firebase op te halen, en de laadbalkjes geleidelijk op te vullen in de tijd dat zij dezelfde stuk tekst correct hebben overgetypt. Dit idee heb ik uiteindelijk gebruikt om de speler te laten 'racen' tegen het persoonlijk record en de absolute high score.

Aan het spel heb ik een teller toegevoegd die de gemaakte fouten moet bijhouden, maar door het gebruik van de TextWatcher werkt deze teller niet naar behoren. De TextWatcher bekijkt bij elke toetsaanslag de hele input string, en vergelijkt deze met de TextView. Ik heb het zodanig geïmplementeerd, omdat de TextWatcher, naast het controleren van de user input, ook de correct- en fout getypte letters met behulp van gekleurde letters moet visualiseren. Als ik met de TextWatcher alleen de relevante letter ter plekke bekijk, kan ik alleen die letter inkleuren; de kleuren van de andere letters in de TextView resetten dan naar wit. Om dit te voorkomen gaat de code dus elke keer weer de hele string af. Het nadeel hiervan is dat wanneer een gebruiker een typfout rechtzet, de foutenteller ook weer omlaag gaat, terwijl het juist de bedoeling is dat hij alle foute aanslagen gedurende het spel bijhoudt. Het is me niet gelukt om dit probleem op tijd te omzeilen. De teller houdt op dit moment alleen de meeste foute aanslagen bij die zich tegelijkertijd in de user input bevinden.

Voor de laadbalkjes had ik in eerste instantie het idee om autootjes te gebruiken die langzamerhand een finish line naderen. Hierdoor zou de app meer lijken op het browserspelletje TypeRacer, dat de inspiratiebron van de app vormt. Het grootste probleem met dit idee is de gebrek aan ruimte; de laadbalkjes zelf nemen al veel ruimte in, en daarbij moet ook nog eens de soft keyboard, de EditText field en de TextView passen. Dit geldt ook voor het toevoegen van land layouts, en daarom heb ik besloten om de speler te forceren in portrait mode te spelen (dit maakt het spel wel enigszins eerlijker, omdat elke speler nu gebruikmaakt van dezelfde opstelling en afmetingen van het toetsenbord). Omdat dit verder geen invloed heeft op de functionaliteit van de app, heb ik me hier niet op gefocust. Uiteindelijk heb ik geen tijd gehad om me hier aan te wijden, waardoor de app nog steeds gebruikmaakt van een simpel laadbalkje.
Ik had ook een tijd moeite met het opbouwen van de Firebase structuur. In eerste instantie had ik namelijk alles onder één node, waarbij zowel de gebruikers als de leaderboard scores werden opgeslagen. Nadat ik echter heb bedacht om alle Leaderboard gerelateerde info in een aparte node op te slaan (om conflicten te voorkomen), is het regelen van opslaan en ophalen van data spoedig verlopen.

Tot slot staat in de design document dat ik gebruik zou maken van verschillende libraries, waaronder Glide en EventBus. Het idee was dat ik hiermee stuk minder code hoefde te schrijven, maar uiteindelijk heb ik de voordelen hiervan overschat. Net als in de AppStudio opdrachten heb ik gewoon gebruikgemaakt van intents en Picasso, en dit is voor deze app prima verlopen. Hierdoor heb ik niet meer dependencies aan mijn code hoeven toevoegen.

De hierbovengenoemde tekortkomingen en geschrapte functionaliteiten nemen niet weg van de kern van de app. Mijn focus lag vooral op het werkende krijgen van het spel en zorgen dat scores op een correcte en efficiënte manier worden opgeslagen en opgehaald. De app voelt nu misschien wat mager doordat ik niet de extra functionaliteiten, API's en libraries heb kunnen toevoegen, maar het spel werkt wel en is bug vrij. Als ik extra tijd had, dan had ik zeker de app meer aangekleed, het spel gebruikersvriendelijker gemaakt, en de layout verder verbeterd (bijvoorbeeld door gebruik van material design).
